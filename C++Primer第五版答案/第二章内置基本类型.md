# 内置基本类型

## 2.1

区别在于他们所能表示的范围以及占用空间的大小。

区别是一个不能表示负数，一个可以。

区别是所能表示的精度。

## 2.2

利率选择float；本金、付款选择double、long double。

理由：利率几乎不会超过100，有效位数足够；本金和付款可能高达百万，需要更高的精度。

## 2.3

```
32
4294967264
32
-32
0
0
```

## 2.4

无

## 2.5

a)char、wchar_t、字符串、宽字符组成的字符串

b)int、unsigned int、long、unsigned long、八进制表示的int、十六进制表示的int

c)double、float、long double

d)int、unsigned int、double、double

## 2.6

第一组是int，第二组是八进制表示的int，但09不合法。

## 2.7

字符串

long double

不合法

long double

## 2.8

```C++
std::cout << "2\115\n";
std::cout << '2' << '\t' << '\115' << '\n';
```

## 2.9

不合法，未声明的变量。

合法，i=3。

不合法，m没有被声明。

合法，i=3。

## 2.10

空字串和0。

## 2.11

声明且定义。

声明且定义。

声明。

## 2.12

不合法。

合法。

不合法。

不合法。

合法。

## 2.13

100。

## 2.14

合法，输出为“100 55”。

## 2.15

合法。

不合法，不是常量引用。

合法。

不合法，引用必须初始化。

## 2.16

均合法。

## 2.17

均输出10。

## 2.18

无

## 2.19

引用一定要初始化，不能定义引用的引用，引用从一而终不能指向别的。指针相反。

## 2.20

即i=i*i;

## 2.21

不合法，指针类型必须和它指向的类型一致。

不合法，要用取地址符。

合法。

## 2.22

如果p不是空指针。

如果p指向的变量不为0。

## 2.23

不能。它只是一个内存地址而已，内存地址记了什么信息跟指针无关。

## 2.24

void*可以存放任意对象地址。

## 2.25

int*、int、int&。

int、int*。

int*、int。

## 2.26

不合法，常量未经初始化。

合法。

合法。

不合法，常量的值不能被修改。

## 2.27

合法。

合法。

合法。

合法。

合法。

不合法，需要初始化。

合法。

## 2.28

不合法，int* const需要初始化。

不合法，int* const需要初始化。

合法。

不合法，const int* const需要初始化。

合法。

## 2.29

合法。

不合法，指针类型不相同。

不合法，指针类型不相同。

合法。

不合法，int* const指针本身是常量。

不合法，const int不能被修改。

## 2.30

顶层const。

不是const。

不是const。

不是const。

底层const。

顶层const。

## 2.31

合法。

不合法，指针类型不同。

合法。

不合法，指针类型不同。

合法。

## 2.32

不合法，因为此时null已经是int类型的变量，不能将int分配给指针。

## 2.33

d不合法，因为d是int*。

e不合法，因为e是const int*。

g不合法，因为g是const int&不能再修改一个常量。

## 2.34

无

## 2.35

j是int。

k是const int&。

p是const int*。

j2是const int。

k2是const int&。

## 2.36

c是int，d是int&。

a=4，b=4，c=4，d=4。

## 2.37

c是int，d是int&

a=3，b=4，c=3，d=3

## 2.38

auto要使用到初始化的表达式，这个表达式需要计算。而decltype只分析但不计算这个表达式。

auto一般会忽略顶层const，保留底层const，decltype会保留顶层const。

```C++
const int i = 42;
const int* const p = &i;
decltype(p) c = &i; // const int* const
auto d = &i; // const int*
```

## 2.39~2.42

无